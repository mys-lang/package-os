from . import BinaryFile
from . import TextFile
from .utils import to_utf8
from . import OsError

c"""source-before-namespace
#include <fstream>
#include <filesystem>
#include <cstdlib>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

static inline int chmod_wrapper(const char *name_p, u32 mode)
{
    return chmod(name_p, mode);
}
"""

class Path:
    """A file system path.

    """

    _parts: [string]

    def __init__(self, path: string):
        if path == "":
            path = "."

        self._parts = []

        if path[0] == '/':
            self._parts.append("/")

        for part in path.split("/"):
            if part in ["", "."]:
                continue

            self._parts.append(part)

    def __eq__(self, other: Path) -> bool:
        return str(self) == str(other)

    def __ne__(self, other: Path) -> bool:
        return not (self == other)

    def name(self) -> string:
        """The final component.

        """

        if len(self._parts) == 0:
            return ""

        name = self._parts[-1]

        if name == "/":
            return ""

        return name

    def stem(self) -> string:
        """The final component without extension.

        """

        extension_length = len(self.extension())

        if extension_length > 0:
            return self.name()[:-extension_length]
        else:
            return self.name()

    def extension(self) -> string:
        """The final component extension, including the dot.

        """

        name = self.name()
        last_dot_index = name.find_reverse('.')

        if last_dot_index <= 0 or last_dot_index == i64(len(name) - 1):
            return ""

        return name[last_dot_index:]

    def parent(self) -> Path:
        """The parent path.

        """

        return Path("/".join(self._parts[:-1]))

    def join(self, other: string) -> Path:
        """Join with other path.

        """

        if self.name() == "" and len(self._parts) == 0:
            return Path("./" + other)
        else:
            return Path(str(self) + "/" + other)

    def join(self, other: Path) -> Path:
        """Join with other path.

        """

        return self.join(str(other))

    def read_text(self) -> string:
        """Read file contents.

        """

        return TextFile(str(self)).read()

    def write_text(self, data: string):
        """Write file contents.

        """

        TextFile(str(self), "w").write(data)

    def read_binary(self) -> bytes:
        """Read file contents.

        """

        return BinaryFile(str(self)).read()

    def write_binary(self, data: bytes):
        """Write file contents.

        """

        BinaryFile(str(self), "w").write(data)

    def exists(self) -> bool:
        """Check for existence.

        """

        return _exists(str(self))

    def mkdir(self, exists_ok: bool = False):
        """Create directories.

        Give `exists_ok` as ``True`` to ignore errors.

        """

        _mkdir(str(self), exists_ok)

    def chmod(self, mode: u32):
        """Change permissions.

        """

        _chmod(str(self), mode)

    def ls(self) -> [Path]:
        """Returns all files and folders.

        """

        dpath = str(self)

        if dpath == "":
            dpath = "."

        return [Path(path) for path in _ls(dpath)]

    def rm(self, recursive: bool = False, force: bool = False):
        """Remove files and directories.

        Give `recursive` as ``True`` to remove all files and folders
        recursivly.

        Give `force` as ``True`` to ignore errors.

        """

        _rm(str(self), recursive, force)

    def touch(self):
        """Update modification time and creates if missing.

        """

        _touch(str(self))

    def __str__(self) -> string:
        return "/".join(self._parts).replace("//", "/")

def _ls(path: string = ".") -> [string]:
    """Returns all files and folders in given directory.

    """

    path_utf8 = to_utf8(path)
    entries: [string] = []

    c"""
    char *path_p = (char *)path_utf8.m_bytes->data();

    for (const auto& entry : std::filesystem::directory_iterator(path_p)) {
        entries->append(entry.path().filename().c_str());
    }
    """

    return entries

def _rm(path: string, recursive: bool = False, force: bool = False):
    """Remove files and directories.

    Give `recursive` as ``True`` to remove all files and folders
    recursivly.

    Give `force` as ``True`` to ignore errors.

    """

    path_utf8 = to_utf8(path)
    message: string = None

    c"""
    std::error_code ec;
    bool ok;

    if (recursive) {
        ok = (std::filesystem::remove_all((char *)path_utf8.m_bytes->data(), ec) > 0);
    } else {
        ok = std::filesystem::remove((char *)path_utf8.m_bytes->data(), ec);
    }

    if (!ok) {
        if (!force) {
            if (ec) {
                message = String(ec.message());
            } else {
                message = String(strerror(ENOENT));
            }
        }
    }
    """

    if message is not None:
        raise OsError(message)

def _mkdir(path: string, exists_ok: bool = False):
    """Create directories.

    Give `exists_ok` as ``True`` to ignore errors.

    """

    path_utf8 = to_utf8(path)
    message: string = None

    c"""
    std::error_code ec;
    bool ok;

    ok = std::filesystem::create_directories((char *)path_utf8.m_bytes->data(), ec);

    if (!ok) {
        if (ec) {
            message = String(ec.message());
        } else if (!exists_ok) {
            message = String(strerror(EEXIST));
        }
    }
    """

    if message is not None:
        raise OsError(message)

def _exists(path: string) -> bool:
    res: bool = False
    path_utf8 = to_utf8(path)

    c"""
    res = std::filesystem::exists((const char *)path_utf8.m_bytes->data());
    """

    return res

def _chmod(path: string, mode: u32):
    """Change permissions of given file.

    """

    message: string = None
    path_utf8 = to_utf8(path)

    c"""
    if (chmod_wrapper((const char *)path_utf8.m_bytes->data(), mode) != 0) {
        message = String(strerror(errno));
    }
    """

    if message is not None:
        raise OsError(message)

def _touch(path: string):
    # ToDo: Only update mtime if exists.
    path_utf8 = to_utf8(path)

    c"""
    std::ofstream MyFile((char *)path_utf8.m_bytes->data());
    """

@test
def test_path():
    assert str(Path("")) == ""
    assert str(Path("foo//bar")) == "foo/bar"
    assert str(Path("foo/./bar")) == "foo/bar"
    assert str(Path("foo/../bar")) == "foo/../bar"

@test
def test_name():
    assert Path("foo/bar.txt").name() == "bar.txt"
    assert Path("").name() == ""
    assert Path("foo.txt").name() == "foo.txt"
    assert Path("/foo/bar").name() == "bar"
    assert Path(".bar").name() == ".bar"
    assert Path("foo.tar.gz").name() == "foo.tar.gz"
    assert Path("a/b/").name() == "b"

@test
def test_stem():
    assert Path("foo/bar.txt").stem() == "bar"
    assert Path("").stem() == ""
    assert Path("foo.txt").stem() == "foo"
    assert Path("/foo/bar").stem() == "bar"
    assert Path(".bar").stem() == ".bar"
    assert Path("..out").stem() == "."
    assert Path("foo.tar.gz").stem() == "foo.tar"
    assert Path("foo.tar.gz.").stem() == "foo.tar.gz."

@test
def test_extension():
    assert Path("foo/bar.txt").extension() == ".txt"
    assert Path("").extension() == ""
    assert Path("bar.tar.gz").extension() == ".gz"
    assert Path("foo.txt").extension() == ".txt"
    assert Path("/foo/bar").extension() == ""
    assert Path(".bar").extension() == ""
    assert Path("..out").extension() == ".out"
    assert Path("foo.tar.gz").extension() == ".gz"
    assert Path("foo.tar.gz.").extension() == ""

@test
def test_parent():
    assert Path("foo/bar.txt").parent() == Path("foo")
    assert Path(".").parent() == Path(".")
    assert Path("foo").parent().parent() == Path(".")

@test
def test_join():
    path = Path("foo").join("bar.txt")
    assert str(path) == "foo/bar.txt"

    path = Path("foo").join("/bar.txt")
    assert str(path) == "foo/bar.txt"

    path = Path("foo/").join("/bar.txt")
    assert str(path) == "foo/bar.txt"

    path = Path("foo").join(Path("bar.txt"))
    assert str(path) == "foo/bar.txt"

    path = Path(".").join(Path("bar.txt"))
    assert str(path) == "bar.txt"

    path = Path("./").join(Path("/bar.txt"))
    assert str(path) == "bar.txt"

    path = Path("").join(Path("/bar.txt"))
    assert str(path) == "bar.txt"

    path = Path("/").join(Path("bar.txt"))
    assert str(path) == "/bar.txt"

    path = Path("").join(Path("/"))
    assert str(path) == ""

@test
def test_ls():
    directory = Path("ls")
    directory.rm(recursive=True, force=True)
    directory.mkdir()
    directory.join("a").mkdir()
    directory.join("b").mkdir()
    directory.join("c").touch()

    entries = directory.ls()

    assert len(entries) == 3
    assert Path("a") in entries
    assert Path("b") in entries
    assert Path("c") in entries

    directory.rm(recursive=True, force=True)

@test
def test_rm():
    directory = "test_rm"
    _rm(directory, recursive=True, force=True)
    _mkdir(directory)
    _rm(directory, recursive=True)
    _mkdir(f"{directory}/foo/bar", exists_ok=True)

    try:
        message = ""
        _rm(directory)
    except OsError as e:
        message = e.message

    assert message == "Directory not empty"

    _rm(directory, recursive=True)

@test
def test_rm_single_file():
    filename = "test_rm_single_file"
    _touch(filename)
    _rm(filename)

    try:
        message = ""
        _rm(filename)
    except OsError as e:
        message = e.message

    assert message == "No such file or directory"

    _rm(filename, force=True)

@test
def test_chmod():
    filename = "cmod"

    _rm(filename, force=True)

    try:
        message = ""
        _chmod(filename, 0o666)
    except OsError as e:
        message = e.message

    assert message == "No such file or directory"

    _touch(filename)
    _chmod(filename, 0o666)
    _rm(filename)

@test
def test_mkdir():
    directory = "adir"
    _rm(directory, force=True)
    _mkdir(directory, exists_ok=True)

    try:
        message = ""
        _mkdir(directory)
    except OsError as e:
        message = e.message

    assert message == "File exists"
